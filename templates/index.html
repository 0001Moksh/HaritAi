<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HaritAI - Waste Recycling Analyzer</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Font: Quicksand -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="icon" href="static/icon.png" type="image/png">

    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;700&display=swap" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        :root {
            --eco-green-dark: #013220; /* Dark Green */
            --eco-green-medium: #2E8B57; /* Sea Green */
            --eco-green-light: #90EE90; /* Light Green */
            --eco-blue: #4682B4; /* Steel Blue */
            --eco-blue-darker: #3a6a94;
            --eco-accent: #3CB371; /* Medium Sea Green */
            --eco-error: #DC143C; /* Crimson Red */
            --eco-bg-start:rgb(2, 101, 41); /* Darker Green */
            --eco-bg-end:rgba(58, 0, 99, 0.7); /* Light Blue */
            /* --eco-card-bg: rgba(255, 255, 255, 0.1); */ /* Old Value */
            --eco-card-bg: rgba(0, 0, 0, 0.52); /* MODIFIED: Slightly less transparent */
            --eco-card-hover-bg: rgba(255, 255, 255, 0.15);
            --eco-text-light: #f0f0f0;
            --eco-text-dark: #333;
            --eco-shadow: rgba(0, 0, 0, 0.3);
        }

        body {
            background: linear-gradient(135deg, var(--eco-bg-start), var(--eco-bg-end));
            background-size: 400% 400%;
            animation: gradientAnimation 5s ease infinite;
            color: var(--eco-text-light);
            text-align: center;
            padding-top: 30px;
            font-family: 'Quicksand', sans-serif;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh; /* Ensure body takes full height */
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        /* --- Floating Leaves Animation --- */
        .particle {
            position: absolute;
            width: 10px; height: 15px;
            background-color: rgba(144, 238, 144, 0.5);
            border-radius: 50% 0 50% 0;
            transform: rotate(-45deg);
            box-shadow: 0 0 6px rgba(144, 238, 144, 0.4);
            pointer-events: none;
            animation: float 15s infinite ease-in-out alternate;
        }

        @keyframes float {
            0% { transform: translateY(0) rotate(-45deg) scale(1); opacity: 0.5; }
            50% { transform: translateY(-20px) translateX(10px) rotate(-35deg) scale(1.1); opacity: 0.7; }
            100% { transform: translateY(10px) translateX(-10px) rotate(-55deg) scale(0.9); opacity: 0.4; }
        }


        .container {
            background: var(--eco-card-bg);
            /* backdrop-filter: blur(10px); */ /* Old Value */
            backdrop-filter: blur(6px); /* MODIFIED: Reduced blur amount */
            -webkit-backdrop-filter: blur(6px); /* MODIFIED: Reduced blur amount for Safari */
            border: 1px solid rgba(255, 255, 255, 0.18);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px 0 var(--eco-shadow);
            max-width: 800px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            margin: 30px auto;
            position: relative;
            z-index: 1;
        }

        h2 {
            color: #fff;
            margin-bottom: 25px;
            font-weight: 700;
        }

        /* --- Upload Section --- */
        #upload-area {
            border: 2px dashed var(--eco-green-light);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 15px; /* Reduced margin */
            transition: background-color 0.3s ease, border-color 0.3s ease;
            cursor: pointer;
        }
        #upload-area:hover, #upload-area.dragover {
            background-color: rgba(0, 255, 0, 0.1);
            border-color: var(--eco-accent);
        }
        #upload-area p { margin: 5px 0; color: var(--eco-text-light); }
        #upload-area .upload-icon { font-size: 2.5rem; color: var(--eco-green-light); margin-bottom: 10px; }
        #fileInput { display: none; }

        /* --- Camera/Refresh Button Group --- */
        .button-group {
            display: flex;
            gap: 10px; /* Space between buttons */
            margin-bottom: 20px; /* Space below the group */
            align-items: stretch; /* Make buttons same height */
        }
        .button-group .btn {
            flex-shrink: 0; /* Prevent shrinking too much */
            white-space: nowrap; /* Prevent text wrapping */
        }
        .btn-refresh i { vertical-align: middle; }
        .button-group .btn:first-child { flex-grow: 1; }


        .image-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 25px;
        }

        .image-item {
            position: relative; text-align: center; overflow: visible;
            border-radius: 10px; box-shadow: 0 4px 8px var(--eco-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            width: 150px; background: rgba(0,0,0,0.25);
            display: flex; flex-direction: column; align-items: center;
        }
        .image-item:hover { transform: translateY(-5px) scale(1.03); box-shadow: 0 6px 12px var(--eco-shadow); }

        /* MODIFIED: Use aspect-ratio for consistent thumbnail size */
        .image-item .thumbnail-container {
            position: relative;
            width: 100%;
            /* height: 150px; */ /* REMOVED fixed height */
            aspect-ratio: 1 / 1; /* ADDED: Makes it square. Change if needed (e.g., 4 / 3) */
            overflow: hidden; /* ADDED: Ensures image stays within bounds */
            border-radius: 10px 10px 0 0; /* Moved radius here */
        }
        .image-item img.thumbnail {
            height: 100%;
            width: 100%;
            /* border-radius: 10px 10px 0 0; */ /* REMOVED: Moved to container */
            object-fit: cover;
            transition: opacity 0.4s ease;
            display: block;
        }

        .image-item .delete-btn {
            position: absolute; top: 5px; right: 5px; background: rgba(220, 20, 60, 0.8); color: white;
            border: none; border-radius: 50%; cursor: pointer;
            /* Base size (can be smaller for desktop if preferred) */
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 24px;
            text-align: center;
            opacity: 0; /* <<< HIDDEN BY DEFAULT (for desktop hover) */
            transition: opacity 0.3s ease, background-color 0.2s ease, transform 0.2s ease;
            z-index: 10;
        }
        /* Show on Desktop Hover */
        .image-item:hover .delete-btn {
            opacity: 1;
        }
        .delete-btn:hover { background: var(--eco-error); transform: scale(1.1); }

        /* --- Processing Animation (Per Image) --- */
        .image-item .processing-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.65);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.4s ease; z-index: 5; pointer-events: none;
            border-radius: 10px 10px 0 0; /* Match container radius */
        }
        .image-item.processing .processing-overlay { opacity: 1; pointer-events: auto; }
        .image-item.processing img.thumbnail { opacity: 0.3; }
        .processing-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3); border-top: 3px solid var(--eco-green-light);
            border-radius: 50%; width: 35px; height: 35px; animation: spin 1s linear infinite; margin-bottom: 8px;
        }
        .processing-text { font-size: 0.85rem; color: var(--eco-text-light); font-weight: 500; }

        /* --- Analysis Result Text (Below Thumbnail) --- */
        .image-item .result-text {
            padding: 10px; /* Slightly more padding */
            font-size: 0.85rem; /* Slightly larger base size */
            color: var(--eco-green-light); font-weight: 500; min-height: 45px; /* Adjusted min-height */
            background: rgba(0,0,0,0.3);
            border-radius: 0 0 10px 10px; width: 100%; text-align: left; opacity: 0; transform: translateY(10px);
            transition: opacity 0.5s 0.1s ease-out, transform 0.5s 0.1s ease-out; white-space: normal; word-wrap: break-word;
        }
        .image-item .result-text.visible { opacity: 1; transform: translateY(0); }
        .image-item .result-text.error { color: var(--eco-error); }


        /* --- Buttons --- */
        .btn {
            transition: all 0.3s ease; border-radius: 8px; padding: 10px 20px; font-weight: 500;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15); border: none; cursor: pointer; margin-top: 10px;
        }
        .btn i { margin-right: 8px; }
        .btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 10px rgba(0, 0, 0, 0.25); }
        .btn:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        .btn:disabled {
            opacity: 0.5 !important; cursor: not-allowed !important; transform: none !important; box-shadow: none !important;
            background-color: #6c757d !important; border-color: #6c757d !important; color: #ccc !important;
        }
        .btn:disabled i { opacity: 0.6; }

        /* **MODIFIED**: Enhanced styling for Upload & Analyze button */
        #upload-analyze-btn {
            background-image: linear-gradient(to right, var(--eco-blue) 0%, var(--eco-blue-darker) 50%, var(--eco-blue) 100%);
            background-size: 200% auto;
            color: white;
            font-weight: bold; /* Make text bolder */
            padding: 12px 25px; /* Slightly larger padding */
            transition: background-position 0.5s ease, transform 0.3s ease, box-shadow 0.3s ease; /* Added background-position transition */
        }
        #upload-analyze-btn:hover:not(:disabled) {
            background-position: right center; /* Change gradient direction on hover */
            transform: translateY(-3px) scale(1.03); /* Slightly more lift */
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
        }
         #upload-analyze-btn:active:not(:disabled) {
             transform: translateY(-1px);
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
         }
        /* Ensure disabled state overrides gradient */
        #upload-analyze-btn:disabled {
             background-image: none !important; /* Remove gradient when disabled */
        }


        .btn-success { background-color: var(--eco-green-medium); color: white; }
        .btn-success:hover:not(:disabled) { background-color: #256d45; }

        .btn-warning { background-color: #ffc107; color: var(--eco-text-dark); }
        .btn-warning:hover:not(:disabled) { background-color: #e0a800; }

        .btn-outline-secondary {
            color: var(--eco-text-light); border: 1px solid var(--eco-green-light); background-color: transparent;
        }
        .btn-outline-secondary:hover:not(:disabled) { background-color: rgba(144, 238, 144, 0.2); color: #fff; border-color: var(--eco-green-light); }

        /* --- Global Action Buttons & Results Area --- */
        #global-actions { margin-top: 30px; border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 20px; }

        /* --- Prediction & Generation Results Area --- */
        #results-area {
            margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.15); border-radius: 8px;
            opacity: 0; transform: translateY(20px); transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            text-align: left; min-height: 100px;
        }
        #results-area.visible { opacity: 1; transform: translateY(0); }

        /* Prediction Text Styling */
        #product-result { color: #fff; font-size: 1rem; margin-bottom: 20px; white-space: pre-line; line-height: 1.6; }
        #product-result b { color: var(--eco-green-light); display: block; margin-top: 10px; margin-bottom: 5px; font-weight: 700; }
        #product-result br + b { margin-top: 5px; }
        #product-result .error { color: var(--eco-error); font-weight: bold; }

        /* Generated Image Container */
        #generated-image-container { margin-top: 15px; min-height: 150px; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #generated-image-container img { max-width: 90%; max-height: 350px; height: auto; border-radius: 10px; box-shadow: 0 6px 12px var(--eco-shadow); animation: zoomIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes zoomIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* Error Image Styling */
        #generated-image-container .error-image { max-width: 60%; opacity: 0.8; filter: grayscale(60%); border: 2px dashed var(--eco-error); padding: 10px; animation: shake 0.5s ease-in-out; }
        #generated-image-container .error-message { color: var(--eco-error); font-size: 0.9rem; margin-top: 10px; font-weight: 500; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 90% { transform: translateX(-4px); } 30%, 70% { transform: translateX(4px); } 50% { transform: translateX(-4px); } }

        /* --- Loading Text Style (Used within result areas) --- */
        .loading-text { color: var(--eco-text-light); font-style: italic; padding: 20px; text-align: center; opacity: 0.8; }
        .loading-text::before { content: ''; display: inline-block; width: 1em; height: 1em; border: 2px solid rgba(255, 255, 255, 0.3); border-top-color: var(--eco-green-light); border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 10px; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- **ADDED**: Page Loader Styles --- */
        #page-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.96); /* Darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999; /* High z-index */
            opacity: 1;
            transition: opacity 0.5s ease-out; /* Faster Fade out transition */
            pointer-events: auto;
        }
        #page-loader .spinner { /* Reusing the spin animation */
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid var(--eco-green-light);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 0.8s linear infinite; /* Slightly slower spin */
        }
        #page-loader.hidden {
            opacity: 0;
            pointer-events: none; /* Allow clicks through after fade */
        }


        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .container { padding: 20px; margin: 20px 15px; }
            .image-item { width: calc(50% - 10px); } /* Keep 2 columns */
            h2 { font-size: 1.6rem; }
            #upload-area { padding: 20px; }
            .button-group { flex-direction: column; gap: 15px; } /* Stack buttons & adjust gap */

            /* --- MOBILE IMPROVEMENT: Make delete button always visible & larger --- */
            .image-item .delete-btn {
                opacity: 1; /* <<< ALWAYS VISIBLE on mobile */
                width: 30px; /* Larger tap target */
                height: 30px;
                font-size: 16px;
                line-height: 30px; /* Center icon */
                /* Optional: Adjust position slightly if needed */
                /* top: 3px; */
                /* right: 3px; */
            }
            /* No need for .image-item:hover .delete-btn here */
        }

        @media (max-width: 480px) {
            .image-list {
                gap: 15px; /* Reduced gap for smallest screens */
            }
            .image-item { width: 100%; } /* Single column */
            .btn { font-size: 0.95rem; padding: 10px 18px; } /* Slightly larger font/padding */
            h2 { font-size: 1.4rem; }
            .image-item .result-text { font-size: 0.9rem; min-height: 40px; } /* Further increase result text size */
            .image-item .processing-text { font-size: 0.9rem; } /* Increased processing text size */
            #results-area { padding: 15px; } /* Reduce padding slightly */
            #generated-image-container img { max-width: 100%; } /* Allow image to use full width */

            /* Delete button styles from 768px will cascade, ensure they are correct */
            .image-item .delete-btn {
                 opacity: 1; /* Ensure it's visible */
                 width: 30px; /* Keep the larger tap target */
                 height: 30px;
                 line-height: 30px;
                 font-size: 16px;
            }
        }

        /* ADDED: Optional - Hide particles on smaller screens for performance */
        @media (max-width: 600px) {
            #particles-container {
                display: none;
            }
        }

    </style>
</head>
<body>
    <!-- **ADDED**: Page Loader Overlay -->
    <div id="page-loader">
        <div class="spinner"></div>
    </div>

    <!-- Background Particles -->
    <div id="particles-container"></div>

    <!-- Main Content Container -->
    <div class="container">
        <h2 class="mb-4"><i class="fas fa-recycle"></i> HaritAI - Waste Analyzer</h2>

        <!-- Upload Area -->
        <div id="upload-area" onclick="document.getElementById('fileInput').click();">
            <input type="file" id="fileInput" accept="image/*" multiple onchange="addImages(event)">
            <div class="upload-icon"><i class="fas fa-cloud-upload-alt"></i></div>
            <p>Drag & Drop Images Here</p>
            <p>or Click to Select Files</p>
        </div>

        <!-- Camera and Refresh Button Group -->
        <div class="button-group">
            <button class="btn btn-outline-secondary" onclick="openCamera()">
                <i class="fas fa-camera"></i> Click a Photo
            </button>
            <button class="btn btn-outline-secondary btn-refresh" onclick="location.reload()">
                <i class="fas fa-sync-alt"></i> Refresh
            </button>
        </div>

        <!-- Image Preview Area -->
        <div id="image-preview" class="image-list">
            <!-- Image previews appear here -->
        </div>

        <!-- Action Buttons Area -->
        <div id="global-actions">
             <!-- Upload & Analyze Button: Visible but initially disabled, with title -->
            <button id="upload-analyze-btn" class="btn btn-primary w-100" onclick="uploadAllImages()" disabled title="Add the image of your waste product">
                <i class="fas fa-cogs"></i> Upload & Analyze
            </button>
            <button id="predict-btn" class="btn btn-success w-100" onclick="predictProduct()" style="display: none;">
                <i class="fas fa-lightbulb"></i> Predict New Product
            </button>
            <button id="generate-btn" class="btn btn-warning w-100" onclick="generateImage()" style="display: none;">
                <i class="fas fa-image"></i> Generate Image of New Product
            </button>
        </div>

        <!-- Prediction & Generation Results Area -->
        <div id="results-area"> <!-- Initially hidden via CSS -->
             <div id="generated-image-container">
                 <!-- Generated image or error image appears here -->
             </div>
            <div id="product-result">
                <!-- Prediction text appears here -->
            </div>
        </div>
    </div>

    <!-- JavaScript Logic -->
    <script>
        let selectedFiles = [];
        let analysisResults = {};
        let analysisCompleteCount = 0;
        let predictionMade = false;

        // DOM References
        const particlesContainer = document.getElementById('particles-container');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('image-preview');
        const uploadAnalyzeBtn = document.getElementById("upload-analyze-btn");
        const predictBtn = document.getElementById("predict-btn");
        const generateBtn = document.getElementById("generate-btn");
        const resultsArea = document.getElementById("results-area");
        const productResult = document.getElementById("product-result");
        const generatedImageContainer = document.getElementById("generated-image-container");
        const pageLoader = document.getElementById('page-loader'); // **ADDED**: Reference to page loader

        // --- Particle Logic ---
        const numParticles = 20; // Adjusted number of particles
        function createParticle() {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            particle.style.left = `${Math.random() * 100}vw`;
            particle.style.top = `${Math.random() * 100}vh`;
            // Adjust animation duration and delay for variety
            const duration = Math.random() * 10 + 10; // 10s to 20s
            const delay = Math.random() * 15; // 0s to 15s delay
            particle.style.animationDuration = `${duration}s`;
            particle.style.animationDelay = `-${delay}s`; // Negative delay starts animation partway through
            particle.style.transform = `scale(${Math.random() * 0.5 + 0.5}) rotate(-45deg)`; // Initial state matches keyframes
            particle.style.opacity = Math.random() * 0.3 + 0.3; // Vary initial opacity slightly
            particlesContainer.appendChild(particle);
        }
        // Check if particles should be displayed before creating them
        if (window.innerWidth > 600) { // Match the CSS media query
             for (let i = 0; i < numParticles; i++) { createParticle(); }
        }


        // --- Drag and Drop ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser default for whole page
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
        });
        uploadArea.addEventListener('drop', handleDrop, false);

        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                fileInput.files = files; // Assign dropped files to the hidden input
                addImages({ target: fileInput }); // Trigger the same handler as file selection
            }
        }

        // --- Image Handling ---
        function addImages(event) {
            let files = event.target.files;
            if (!files || files.length === 0) return;

            let newFilesAdded = false;
            for (let i = 0; i < files.length; i++) {
                let file = files[i];
                // Basic validation: Check if it's an image and not already added
                if (!file.type.startsWith('image/')) {
                     console.warn(`Skipping non-image file: ${file.name}`);
                     showCustomAlert(`Skipped: ${file.name} is not an image.`);
                     continue;
                }
                const fileId = `${file.name}-${file.lastModified}`;
                if (selectedFiles.some(f => `${f.name}-${f.lastModified}` === fileId)) {
                     console.log(`Skipping duplicate file: ${file.name}`);
                     // Optional: show alert for duplicate
                     // showCustomAlert(`Skipped: ${file.name} is already added.`);
                     continue;
                }

                selectedFiles.push(file);
                newFilesAdded = true;
                let reader = new FileReader();
                reader.onload = function(e) { createImageItem(file, e.target.result); };
                reader.readAsDataURL(file);
            }

             if (newFilesAdded) {
                 checkAnalyzeButtonState(); // Update analyze button state
                 // If prediction/generation was already done, reset that part
                 if (predictionMade || generatedImageContainer.innerHTML !== '') {
                     resetPredictionGenerationState();
                 }
                 checkPredictButtonState(); // Hide predict button if new files added
             }
             // Reset file input to allow selecting the same file again after removal
             event.target.value = null;
        }

        function createImageItem(file, imageSrc) {
            let div = document.createElement("div");
            div.classList.add("image-item");
            const fileId = `${file.name}-${file.lastModified}`;
            div.dataset.fileId = fileId; // Use dataset for easier selection

            let thumbnailContainer = document.createElement("div");
            thumbnailContainer.classList.add("thumbnail-container"); // Container for aspect ratio

            let img = document.createElement("img");
            img.src = imageSrc; img.alt = `Preview of ${file.name}`; img.classList.add("thumbnail");

            let deleteBtn = document.createElement("button");
            deleteBtn.innerHTML = "&times;"; // Use HTML entity for 'x'
            deleteBtn.classList.add("delete-btn");
            deleteBtn.setAttribute('aria-label', `Remove ${file.name}`);
            deleteBtn.onclick = function(event) {
                event.stopPropagation(); // Prevent triggering other clicks if needed
                const fileIdToRemove = div.dataset.fileId;
                const indexToRemove = selectedFiles.findIndex(f => `${f.name}-${f.lastModified}` === fileIdToRemove);

                if (indexToRemove > -1) {
                    const removedFile = selectedFiles.splice(indexToRemove, 1)[0];
                    delete analysisResults[fileIdToRemove]; // Remove analysis result too
                    console.log(`Removed file: ${removedFile.name}`);
                } else {
                    console.warn(`Could not find file with ID ${fileIdToRemove} for removal.`);
                }
                imagePreview.removeChild(div); // Remove the item from the DOM

                checkAnalyzeButtonState(); // Update analyze button state
                checkPredictButtonState(); // Update predict button state

                // If no files left, reset everything
                if (selectedFiles.length === 0) {
                    resetUIState();
                } else {
                    // Otherwise, just reset prediction/generation if it was shown
                    resetPredictionGenerationState();
                }
            };

            // Processing Overlay Elements
            let processingOverlay = document.createElement("div");
            processingOverlay.classList.add("processing-overlay");
            let spinner = document.createElement("div"); spinner.classList.add("processing-spinner");
            let processingText = document.createElement("p"); processingText.classList.add("processing-text"); processingText.innerText = "Analyzing...";
            processingOverlay.appendChild(spinner); processingOverlay.appendChild(processingText);

            // Append elements to thumbnail container
            thumbnailContainer.appendChild(img);
            thumbnailContainer.appendChild(deleteBtn);
            thumbnailContainer.appendChild(processingOverlay);

            // Result Text Element (below thumbnail)
            let resultText = document.createElement("p");
            resultText.classList.add("result-text");

            // Append main parts to the image item div
            div.appendChild(thumbnailContainer);
            div.appendChild(resultText);

            // Add the new item to the preview area
            imagePreview.appendChild(div);
        }

        function openCamera() {
            // Create a temporary file input element
            let input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*"; // Accept only images
            input.capture = "environment"; // Prefer back camera

            // Add event listener for when a file is selected
            input.onchange = function(event) {
                addImages(event); // Use the same function to handle the captured image
            };

            // Programmatically click the input to open the camera/file picker
            input.click();
        }

        // --- UI State Management ---

        function checkAnalyzeButtonState() {
             const hasFiles = selectedFiles.length > 0;
             uploadAnalyzeBtn.disabled = !hasFiles; // Enable only if files exist
             // Update tooltip based on state
             if (uploadAnalyzeBtn.disabled) {
                 uploadAnalyzeBtn.setAttribute('title', 'Add the image of your waste product');
             } else {
                 uploadAnalyzeBtn.removeAttribute('title');
             }
        }

        function checkPredictButtonState() {
             // Enable predict button only if there are files AND all of them have analysis results
             const allAnalyzed = selectedFiles.length > 0 && selectedFiles.every(file => {
                 const fileId = `${file.name}-${file.lastModified}`;
                 return analysisResults[fileId]; // Check if result exists for this fileId
             });
             predictBtn.style.display = allAnalyzed ? "block" : "none";
        }

        function resetUIState() {
            // Clear data arrays
            selectedFiles = [];
            analysisResults = {};
            analysisCompleteCount = 0;
            predictionMade = false;

            // Clear UI elements
            imagePreview.innerHTML = ''; // Remove all image previews
            productResult.innerHTML = ""; // Clear prediction text
            generatedImageContainer.innerHTML = ""; // Clear generated image

            // Reset button states
            uploadAnalyzeBtn.disabled = true;
            uploadAnalyzeBtn.setAttribute('title', 'Add the image of your waste product'); // Reset tooltip
            predictBtn.style.display = "none";
            generateBtn.style.display = "none";

            // Hide results area
            resultsArea.classList.remove('visible');
            console.log("UI Reset");
        }

        function resetPredictionGenerationState() {
             predictionMade = false;
             generateBtn.style.display = "none"; // Hide generate button
             productResult.innerHTML = ""; // Clear prediction text
             generatedImageContainer.innerHTML = ""; // Clear generated image
             resultsArea.classList.remove('visible'); // Hide the results area
             console.log("Prediction/Generation State Reset");
        }

        // Use standard browser alert for simplicity
        function showCustomAlert(message) {
            alert(message);
        }

        // --- API Call Functions ---

        function uploadAllImages() {
            if (selectedFiles.length === 0) {
                showCustomAlert("Please add the waste product's image first.");
                return;
            }

            // --- Start Analysis Process ---
            uploadAnalyzeBtn.disabled = true; // Disable button during upload/analysis
            uploadAnalyzeBtn.removeAttribute('title'); // Remove tooltip while active
            predictBtn.style.display = "none"; // Hide predict button during analysis

            resetPredictionGenerationState(); // Clear previous prediction/generation results
            analysisCompleteCount = 0; // Reset counter for parallel requests

            // Clear previous results and reset UI for each item before new analysis
            selectedFiles.forEach(file => {
                const fileId = `${file.name}-${file.lastModified}`;
                delete analysisResults[fileId]; // Clear any old result for this file
                let imageItem = imagePreview.querySelector(`.image-item[data-file-id="${CSS.escape(fileId)}"]`); // Use CSS.escape for potentially complex IDs
                if (imageItem) {
                    let resultTextElement = imageItem.querySelector(".result-text");
                    resultTextElement.classList.remove("visible", "error");
                    resultTextElement.innerText = ""; // Clear text
                    imageItem.classList.remove("processing"); // Ensure spinner is hidden initially
                }
            });

            let analysisPromises = []; // To track completion of all requests

            selectedFiles.forEach(file => {
                const fileId = `${file.name}-${file.lastModified}`;
                let imageItem = imagePreview.querySelector(`.image-item[data-file-id="${CSS.escape(fileId)}"]`);

                // Only process if the UI element exists and no result exists yet (or re-analyzing)
                if (imageItem) { // Removed !analysisResults[fileId] check to allow re-analysis
                    let resultTextElement = imageItem.querySelector(".result-text");
                    imageItem.classList.add("processing"); // Show PER-IMAGE spinner

                    let formData = new FormData();
                    formData.append("file", file);

                    // Create a promise for each fetch request
                    const analysisPromise = fetch('/upload_image', { method: "POST", body: formData })
                        .then(response => {
                            if (!response.ok) { // Check for HTTP errors (like 500, 404)
                                 return response.json().then(errData => { // Try to parse error JSON
                                     throw new Error(errData.error || `HTTP error! Status: ${response.status}`);
                                 }).catch(() => { // If no JSON body, throw generic error
                                     throw new Error(`HTTP error! Status: ${response.status}`);
                                 });
                            }
                            return response.json(); // Parse successful JSON response
                        })
                        .then(data => {
                            if (data.error) { // Check for application-level errors in JSON
                                throw new Error(data.error);
                            }
                            // Success: Update UI and store result
                            resultTextElement.innerText = data.description || "Analysis complete.";
                            resultTextElement.classList.add("visible");
                            resultTextElement.classList.remove("error"); // Ensure error class is removed
                            analysisResults[fileId] = { status: 'success', description: data.description };
                        })
                        .catch(error => {
                            // Failure: Update UI with error and store error status
                            console.error("Error analyzing image:", file.name, error);
                            resultTextElement.innerText = `Error: ${error.message.substring(0, 100)}...`; // Show truncated error
                            resultTextElement.classList.add("visible", "error");
                            analysisResults[fileId] = { status: 'error', description: error.message };
                        })
                        .finally(() => {
                            // Always run: Hide spinner and increment counter
                            imageItem.classList.remove("processing");
                            analysisCompleteCount++;
                            // Check if all analyses are complete
                            if (analysisCompleteCount === selectedFiles.length) {
                                uploadAnalyzeBtn.disabled = false; // Re-enable button
                                checkPredictButtonState(); // Show predict button if all succeeded (or some failed)
                                checkAnalyzeButtonState(); // Re-check title state
                                console.log("All analyses finished.");
                            }
                        });
                    analysisPromises.push(analysisPromise);
                } else {
                     // Handle case where UI element is missing (shouldn't normally happen)
                     console.error(`Could not find image item for ${file.name}`);
                     analysisCompleteCount++; // Still count it to avoid blocking completion check
                     analysisResults[fileId] = { status: 'error', description: 'UI element missing.' };
                }
            });

             // Handle case where there were no files to process (e.g., all duplicates)
             if (selectedFiles.length === 0) {
                 uploadAnalyzeBtn.disabled = true;
                 checkAnalyzeButtonState();
             } else if (analysisCompleteCount === selectedFiles.length) {
                 // If all items were already processed (e.g., UI missing), re-enable button immediately
                 uploadAnalyzeBtn.disabled = false;
                 checkPredictButtonState();
                 checkAnalyzeButtonState();
             }
        }

        function predictProduct() {
            // --- Pre-checks ---
             const successfulAnalyses = Object.values(analysisResults).filter(res => res.status === 'success');
             if (successfulAnalyses.length === 0) {
                 showCustomAlert("No successfully analyzed waste to predict a product from. Please analyze images first.");
                 return;
             }
             if (selectedFiles.length === 0) {
                 showCustomAlert("No images available for prediction.");
                 return;
             }
             // Optional: Check if all are analyzed, even if some failed? Depends on backend logic.
             // if (!selectedFiles.every(file => analysisResults[`${file.name}-${file.lastModified}`])) {
             //     showCustomAlert("Please ensure all images are analyzed first (even if some failed)."); return;
             // }

            // --- Start Prediction Process ---
            predictBtn.disabled = true; // Disable during request
            generateBtn.style.display = "none"; // Hide generate button
            generatedImageContainer.innerHTML = ""; // Clear previous image

            // Show loading indicator in results area
            productResult.innerHTML = `<p class="loading-text">Predicting product...</p>`;
            resultsArea.classList.add('visible'); // Make sure results area is visible

            fetch('/predict_product', { method: "GET" })
                .then(response => {
                     if (!response.ok) {
                         return response.json().then(errData => { throw new Error(errData.error || `HTTP error! Status: ${response.status}`); })
                                          .catch(() => { throw new Error(`HTTP error! Status: ${response.status}`); });
                     }
                     return response.json();
                 })
                .then(data => {
                    if (data.error) { throw new Error(data.error); }
                    // Format the prediction text - assuming backend sends structured data
                    let predictionHtml = "No suggestion available.";
                    if (data.suggested_product) {
                        // Example: Assuming data.suggested_product is like "Based on [Waste Types], you can make:\n\n**Product:** [Product Name]\n**Description:** [Product Description]"
                        // We can format this better with HTML
                        predictionHtml = data.suggested_product
                            .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>') // Bold text like **Product:**
                            .replace(/\n/g, '<br>'); // Convert newlines to <br>
                    }
                    productResult.innerHTML = predictionHtml;
                    predictionMade = true; // Set flag
                    generateBtn.style.display = "block"; // Show generate button
                })
                .catch(error => {
                    console.error("Error predicting product:", error);
                    productResult.innerHTML = `<p class="error">ðŸš« Prediction Error: ${error.message}</p>`;
                    predictionMade = false; // Reset flag
                    generateBtn.style.display = "none"; // Hide generate button
                })
                .finally(() => {
                    predictBtn.disabled = false; // Re-enable predict button
                });
        }

        function generateImage() {
            if (!predictionMade) {
                showCustomAlert("Please get a successful product prediction first.");
                return;
            }

            // --- Start Image Generation Process ---
            generateBtn.disabled = true; // Disable during request

            // Show loading indicator in image container
            generatedImageContainer.innerHTML = `<p class="loading-text">Generating image...</p>`;
            resultsArea.classList.add('visible'); // Ensure results area is visible

            const errorImageUrl = 'static/error.jpg'; // Define fallback image path

            fetch('/generate_product_image', { method: "GET" })
                 .then(response => {
                     if (!response.ok) {
                         return response.json().then(errData => { throw new Error(errData.error || `HTTP error! Status: ${response.status}`); })
                                          .catch(() => { throw new Error(`HTTP error! Status: ${response.status}`); });
                     }
                     return response.json();
                 })
                .then(data => {
                    if (data.error) { throw new Error(data.error); }
                    if (data.image_url) {
                        // Create image element with error handling
                        generatedImageContainer.innerHTML = `
                            <img src="${data.image_url}"
                                 alt="Generated eco-friendly product"
                                 onerror="this.onerror=null; this.src='${errorImageUrl}'; this.classList.add('error-image'); this.alt='Failed to load generated image.'">`;
                    } else {
                        throw new Error("Image URL not found in response.");
                    }
                })
                .catch(error => {
                    console.error("Error generating image:", error);
                    // Display error image and message
                    generatedImageContainer.innerHTML = `
                        <img src="${errorImageUrl}" class="error-image" alt="Image generation failed">
                        <p class="error-message">ðŸš« <strong>Error:</strong> <span>${error.message || 'Image generation failed.'}</span></p>`;
                })
                .finally(() => {
                    generateBtn.disabled = false; // Re-enable generate button
                });
        }

        // --- Initial Page Setup ---
        checkAnalyzeButtonState(); // Set initial state of the analyze button (disabled, with title)

        // **ADDED**: Page load listener to hide loader
        window.onload = () => {
            if(pageLoader) { // Check if element exists
                 pageLoader.classList.add('hidden');
                 // Optional: Remove from DOM after transition for performance
                 setTimeout(() => {
                     if (pageLoader && pageLoader.parentNode) { // Check again if still exists and attached
                         pageLoader.parentNode.removeChild(pageLoader);
                     }
                 }, 500); // Match CSS transition duration (adjust if needed)
            }
        };

    </script>

</body>
</html>
